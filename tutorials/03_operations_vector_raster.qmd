---
title: "Operations with vector and raster data"
author: "Rilquer Mascarenhas"
format: html
editor: visual
---

> ## Learning Objectives
>
> -   Extract raster data based on vector data
>
> -   Operations with vector data: intersection, dissolve/union, clip and buffer
>
> ##### Functions taught in this tutorial:
>
> `extract()`, `lapply()`, `sapply()`, `group_by()`, `mutate()`
>
> ##### Packages used in this tutorial:
>
> `raster`, `sf`, `ggplot2`, `dplyr`

Now that we have learned how to do some basic manipulations with vector and raster data types in R, in this and the next tutorial, we will explore how to manipulate and combine these two data types to extract data in specific ways to answer our questions.

## 1. Extracting raster data based on a shapefile

In the previous tutorial, we saw how to extract data from raster files, and went over one approach to extract specific data for a specific region, i.e., climatic conditions for NY state. There, we chose to 1) subset our `states` object to obtain a shapefile that has one feature only corresponding to NY state (use the `filter()` function from the `tidyverse` package); 2) reduce our raster to the region of the NY state using the `mask()` function; and then 3) extract data from that reduced raster using the `rasterToPoints()` function. Here, we will bypass the `filter()` and `mask()` function and directly extract data from our raster based on several polygons, using a different function from the `raster` package.

First, let's load the needed packages:

```{r}
library(raster)
library(sf)
```

Now, let's create our objects again, in case we don't have them in our environment (if you do, no need to run this):

```{r}
# We read the states shapefile using read_sf()
states <- read_sf('data/shapefiles/us_state_boundaries/ne_110m_admin_1_states_provinces.shp')

# We read the temperature raster using raster()
mean_temp <- raster('data/raster_files/wc2.1_5m_bio_1.tif')
```

Let's say that, for our analyses (to be done in the next tutorials), we want to understand how temperature, precipitation and elevation are correlated across the states of the US. [In the previous tutorial](https://htmlpreview.github.io/?https://github.com/Rilquer/gcdi-mapping-user-group/blob/main/tutorials/02_intro_raster_R.html), we did some data extraction, manipulation and visualization to start answering that question. We used `rasterToPoints()` to transform all values in a raster into a dataframe. Here, we will use the function `extract()`, which allows us to provide a shapefile to guide the extraction of values.

```{r}
temp_per_state <- extract(mean_temp,states)
```

The function `extract()` returns a list where each element corresponds to one of the features in the original shapefile (in our case, each feature is a state). To know which element corresponds to which state, we should name those elements. Because they follow the order of the features in the shapefile, we can just do:

```{r}
names(temp_per_state) <- states$name
```

With the data organized in this list, now we can extract some summary statics for each state. For instance, we can use the function `mean()` to calculate the average temperature for each element (i.e, each state). A neat way to apply the same function to all elements in a list is to use the functions from [apply](https://www.datacamp.com/tutorial/r-tutorial-apply-family) family. This family is present in basic R (meaning you don't need to install any packages), and is populated with functions to perform repetitive actions across matrices, dataframes and lists.

Here, we will use the function `sapply()`, which applies a specified function to all elements within a list, and returns vector from it. We provide to it: 1) the list we want to use; 2) the function we want to apply to the list; 3) any additional argument to the function. here, we specify `na.rm = TRUE`, in order to remove `NA` values that might have shown up from our raster extraction.

```{r message=FALSE,warning=FALSE}
avg_temp_per_state <- sapply(temp_per_state, mean, na.rm = TRUE)
```

> `NA` values may show up when you perform a raster extraction based on a shapefile, because the raster cells and the polygon shapes don't always align perfectly. This is specially true when working near the coastline: a polygon line may accurately reflect the coastline whereas a raster file will have square-shaped cells with sizes depending on the resolution and that may not perfectly cover all the area within the polygon. Therefore, sometimes the function will attempt to extract an area within the polygon that is not covered by a cell.

Now we have a named vector with the average temperature per state. Since the order of states in this vector is the same as order of states in `states` shapefile, we can directly add that column to the shapefile using the function `mutate()` from the `tidyverse` package. This function basically creates a new column in your dataframe with the values you provide, so you just need to name your new column and say it's equal to the vector we just created.

> Note that we can only use `mutate()` because the order of the states is the same in both the shapefile and the vector we created. If that was not the case, we would need R to activelly look into the shapefile and the vector and match the values of average temperature to the correct state based on a third column that would have the names of the states. We did something similar to add the GDP values in our [Intro to Vector Data](http://htmlpreview.github.io/?https://github.com/Rilquer/gcdi-mapping-user-group/blob/main/tutorials/01_intro_vector_R.html) tutorial.

```{r}
states <- states %>% mutate(avg_temp = avg_temp_per_state)
```

Now, we can use `ggplot` to make a map:

```{r}
library(ggplot2)
ggplot(data = states, aes(fill = avg_temp)) + geom_sf()
```

> #### Exercise
>
> How would you proceed to making a map of the standard deviation of temperature in each state?
>
> *Hint:* you can calculate the standard deviation of a collection of values using the `sd()` function.

## 2. Modifying our shapefile to guide extraction

What if...

```{r}
states_un <- states %>% group_by(region_sub) %>% 
  mutate(geometry = st_union(geometry))

library(ggplot2)
ggplot(data = states_un) + geom_sf()



values_region <- extract(temp,states_un)
unique(states$region_sub)
```

[More resources for vector manipulation](http://www.geo.hunter.cuny.edu/~ssun/R-Spatial/spatialops.html)

Buffer
